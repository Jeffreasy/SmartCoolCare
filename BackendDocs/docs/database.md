# Database Guardrails

## üè∞ The Database Fortress
Per **Anti-Gravity Law 3**, the database is treated as a fortress. Access is strictly controlled, and raw SQL construction is forbidden in the application layer.

### Technology Stack
- **Engine**: PostgreSQL 15+
- **Driver**: `pgx/v5` (High performance, binary protocol)
- **Interface**: `sqlc` (Type-safe SQL compiler)

---

## üìê Schema Overview

The schema is designed for multi-tenancy and strict isolation.

### Core Tables
1.  **Tenants (`tenants`)**
    - The root of isolation. Every user and resource belongs to a context (though users can belong to multiple tenants via memberships).
    - **Key Fields**: `slug` (public ID), `public_key`, `secret_key`, `allowed_origins`, `app_url`.

2.  **Users (`users`)**
    - Global identity. Authenticates via Email/Password.
    - **Security**:
        - Passwords: Bcrypt hash.
        - **MFA**: `mfa_secret` (encrypted/stored) and `mfa_enabled` flag.

3.  **Memberships (`memberships`)**
    - Join table linking `Users` <-> `Tenants`.
    - Defines `role` (e.g., `admin`, `viewer`).

4.  **Refresh Tokens (`refresh_tokens`)**
    - Long-lived revocable tokens for rotating access.
    - **Security**: Stored as hashes (`token_hash`), not raw tokens.
    - **Metadata**: Stores `ip_address` and `user_agent` for Session Management.
    - **Rotation**: Stores `family_id` and `parent_token_id` to detect reuse and chain revocation.

5.  **Verification Tokens (`verification_tokens`)**
    - Short-lived, single-use tokens for Password Reset and Email Verification.
    - **Security**: **SHA256** hashed. Deterministic lookup allows strictly scoped lifecycle management.

6. **MFA Backup Codes (`mfa_backup_codes`)**
    - **Hashed** recovery codes. Linked to User.
    - Fields: `code_hash`, `used` (bool), `used_at`.

7. **Invitations (`invitations`)**
    - Pre-registration access tokens.
    - Fields: `email`, `role`, `tenant_id`, `token_hash`, `expires_at`.

8. **Audit Logs (`audit_logs`)**
    - **Append-only** immutable security event log (Core Domain #4: Integriteit & Verantwoording).
    - **Purpose**: Onweerlegbaar vastleggen van alle kritieke acties binnen het systeem.
    - **Key Fields**:
        - `actor_id`: Who performed the action (User UUID, nullable for system events).
        - `session_id`: Link to session context (refresh token family).
        - `tenant_id`: Tenant scope for multi-tenancy isolation.
        - `action`: Event type (e.g., `auth.login`, `user.delete`, `tenant.modify`).
        - `target_id`: Resource UUID affected by the action.
        - `metadata`: JSONB column for contextual details (diffs, original values, etc.).
        - `ip_address`, `user_agent`, `request_id`: Request correlation data.
    - **Indices**: Optimized for queries by `timestamp DESC`, `actor_id`, `tenant_id`, `action`.
    - **Security**: Database-level constraints prevent UPDATE/DELETE operations (see Migration 007).

---

## üõ°Ô∏è SQLC & Type Safety

We do not write `SELECT * FROM ...` in Go strings. We write SQL in `.sql` files, and `sqlc` generates the Go code.

**Workflow:**
1.  Edit `internal/storage/queries/*.sql`.
2.  Run `sqlc generate`.
3.  Call the generated methods in `internal/storage/db/`.

**Why?**
- **Zero SQL Injection**: Parameters are strictly typed.
- **Fail Fast**: Syntax errors are caught at compile time, not runtime.
- **Performance**: Optimized prepared statements.

### Example Pattern
*Bad (Forbidden):*
```go
db.Query("SELECT * FROM users WHERE email = '" + email + "'") // ‚ùå VULNERABLE
```

*Good (Enforced):*
```go
// Generated by sqlc
user, err := queries.GetUserByEmail(ctx, email) // ‚úÖ SAFE
```

---

## üîí Row Level Security & Isolation

Every query targeting tenant-specific data **MUST** include a `tenant_id` WHERE clause.

- **Correct**: `WHERE user_id = $1 AND tenant_id = $2`
- **Incorrect**: `WHERE user_id = $1` (This creates an IDOR vulnerability)

### Future: Native Row Level Security (RLS)
**Roadmap Target: Phase 50 (Q2 2026)**

We **will** enable PostgreSQL Native Row Level Security (RLS) as a defense-in-depth measure. This ensures that even if application-level tenant filtering is bypassed due to a bug, the database itself enforces isolation at the row level.

**Implementation Plan:**
- Apply RLS policies to `memberships`, `refresh_tokens`, `invitations`, and all tenant-scoped resources.
- Policies will validate `current_setting('app.tenant_id')` against row-level `tenant_id`.
- Application sets session variable via `SET LOCAL app.tenant_id = $1` in transaction context.

*This is not optional. Multi-tenancy at the application layer alone is insufficient for Zero Trust compliance.*
